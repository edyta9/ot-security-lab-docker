{"version":3,"sources":["modbus-server.js"],"names":["module","exports","RED","install","modbus","require","net","internalDebugLog","message","config","this","name","logEnabled","hostname","serverPort","parseInt","responseDelay","delayUnit","showStatusActivities","coilsBufferSize","holdingBufferSize","inputBufferSize","discreteBufferSize","verboseLogging","node","settings","verbose","modbusServer","modbusLogLevel","mbBasics","netServer","coils","alloc","holding","input","Buffer","discrete","calc_rateByUnit","client","socket","JSON","stringify","address","remoteAddress","remotePort","setNodeStatusTo","err","code","showErrors","error","warn","coreServer","isValidMemoryMessage","msg","buildMessage","payload","type","on","writeToServerMemory","send","isValidMessage","disableMsgOutput","done","removeAllListeners"],"mappings":"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","file":"../modbus-server.js","sourcesContent":["/**\n Copyright (c) since the year 2016 Klaus Landsdorf (http://plus4nodered.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Server node.\n * @module NodeRedModbusServer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const modbus = require('jsmodbus')\n  const net = require('net')\n  const coreServer = require('./core/modbus-server-core')\n  const mbBasics = require('./modbus-basics')\n  const internalDebugLog = require('debug')('contribModbus:server')\n\n  function ModbusServer (config) {\n    RED.nodes.createNode(this, config)\n\n    const bufferFactor = 8\n\n    this.name = config.name\n    this.logEnabled = config.logEnabled\n    this.hostname = config.hostname || '0.0.0.0'\n    this.serverPort = parseInt(config.serverPort)\n    this.responseDelay = parseInt(config.responseDelay) || 1\n    this.delayUnit = config.delayUnit\n    this.showStatusActivities = config.showStatusActivities || false\n    this.coilsBufferSize = parseInt(config.coilsBufferSize * bufferFactor)\n    this.holdingBufferSize = parseInt(config.holdingBufferSize * bufferFactor)\n    this.inputBufferSize = parseInt(config.inputBufferSize * bufferFactor)\n    this.discreteBufferSize = parseInt(config.discreteBufferSize * bufferFactor)\n\n    this.showErrors = config.showErrors\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n\n    node.netServer = null\n    node.modbusServer = null\n\n    mbBasics.setNodeStatusTo('initialized', node)\n\n    let modbusLogLevel = 'warn'\n    if (RED.settings.verbose) {\n      /* istanbul ignore next */\n      modbusLogLevel = 'debug'\n    }\n\n    try {\n      node.netServer = new net.Server()\n      node.modbusServer = new modbus.server.TCP(node.netServer, {\n        logLabel: 'ModbusServer',\n        logLevel: modbusLogLevel,\n        logEnabled: node.logEnabled,\n        responseDelay: mbBasics.calc_rateByUnit(node.responseDelay, node.delayUnit),\n        coils: Buffer.alloc(node.coilsBufferSize, 0),\n        holding: Buffer.alloc(node.holdingBufferSize, 0),\n        input: Buffer.alloc(node.inputBufferSize, 0),\n        discrete: Buffer.alloc(node.discreteBufferSize, 0)\n      })\n\n      node.modbusServer.on('connection', function (client) {\n        internalDebugLog('Modbus Server client connection')\n        if (client && client.socket) {\n          internalDebugLog('Modbus Server client to ' + JSON.stringify(client.socket.address()) + ' from ' + client.socket.remoteAddress + ' ' + client.socket.remotePort)\n        }\n\n        // NOTE(Kay): Get the underlying socket of the client connection\n        const socket = client.socket\n        // NOTE(Kay): This event listener is making sure that node-RED does not crash, as jsmodbus isn't handling\n        //           the error internally we need to handle the exception here!\n        socket.on('error', function (err) {\n          internalDebugLog('client connection failure' + err.code)\n        })\n\n        mbBasics.setNodeStatusTo('active', node)\n      })\n\n      node.netServer.listen(node.serverPort, node.hostname, () => {\n        internalDebugLog('Modbus Server listening on modbus://' + node.hostname + ':' + node.serverPort)\n        mbBasics.setNodeStatusTo('initialized', node)\n      })\n\n      if (!node.showStatusActivities) {\n        mbBasics.setNodeDefaultStatus(node)\n      }\n    } catch (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.warn(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    }\n\n    node.netServer.on('error', function (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    })\n\n    node.on('input', function (msg) {\n      if (coreServer.isValidMemoryMessage(msg)) {\n        coreServer.writeToServerMemory(node, msg)\n        if (!msg.payload.disableMsgOutput) {\n          node.send(buildMessage(msg))\n        }\n      } else {\n        if (node.showErrors) {\n          node.error('Is Not A Valid Memory Write Message To Server', msg)\n        }\n        if (coreServer.isValidMessage(msg) && !msg.payload.disableMsgOutput) {\n          node.send(buildMessage(msg))\n        }\n      }\n    })\n\n    function buildMessage (msg) {\n      return [\n        { type: 'holding', message: msg, payload: node.modbusServer.holding },\n        { type: 'coils', message: msg, payload: node.modbusServer.coils },\n        { type: 'input', message: msg, payload: node.modbusServer.input },\n        { type: 'discrete', message: msg, payload: node.modbusServer.discrete },\n        { payload: 'request', type: 'message', message: msg }\n      ]\n    }\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n\n      if (node.netServer) {\n        node.netServer.close(() => {\n          internalDebugLog('Modbus Server closed')\n          done()\n          node.removeAllListeners()\n          node.netServer.removeAllListeners()\n        })\n      } else {\n        done()\n        node.removeAllListeners()\n      }\n\n      node.modbusServer = null\n    })\n  }\n\n  try {\n    RED.nodes.registerType('modbus-server', ModbusServer)\n  } catch (err) {\n    /* istanbul ignore next */\n    internalDebugLog(err.message)\n  }\n}\n"]}